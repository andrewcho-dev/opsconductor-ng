#!/usr/bin/env python3
"""
Enhanced Targets Service - Multi-Service Architecture
Supports both legacy single-service and new multi-service targets
"""

import os
import json
import logging
from datetime import datetime
from typing import List, Optional, Dict, Any

import psycopg2
import psycopg2.extras
import requests
from fastapi import FastAPI, HTTPException, Depends, status, Query
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv

# Import our enhanced models
from models import (
    ServiceDefinition, ServiceDefinitionResponse,
    TargetServiceCreate, TargetServiceUpdate, TargetService,
    TargetCredentialCreate, TargetCredential,
    TargetCreate, TargetUpdate, Target, TargetListResponse,
    LegacyTargetCreate, LegacyTarget, LegacyTargetListResponse,
    BulkServiceOperation, BulkServiceResponse,
    MigrationStatus
)

# Load environment variables
load_dotenv()

# Logging setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# FastAPI app
app = FastAPI(
    title="Enhanced Targets Service", 
    version="2.0.0",
    description="Multi-service target management with backward compatibility"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Security
security = HTTPBearer()

# Configuration
AUTH_SERVICE_URL = os.getenv("AUTH_SERVICE_URL", "http://auth-service:3001")
CREDENTIALS_SERVICE_URL = os.getenv("CREDENTIALS_SERVICE_URL", "http://credentials-service:3004")

# Database configuration
DB_HOST = os.getenv("DB_HOST", "postgres")
DB_PORT = os.getenv("DB_PORT", "5432")
DB_NAME = os.getenv("DB_NAME", "opsconductor")
DB_USER = os.getenv("DB_USER", "postgres")
DB_PASSWORD = os.getenv("DB_PASSWORD", "postgres123")

def get_db_connection():
    """Get database connection"""
    return psycopg2.connect(
        host=DB_HOST,
        port=DB_PORT,
        database=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        cursor_factory=psycopg2.extras.RealDictCursor
    )

# Auth functions
async def verify_token_with_auth_service(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify token with auth service"""
    try:
        response = requests.get(
            f"{AUTH_SERVICE_URL}/verify",
            headers={"Authorization": f"Bearer {credentials.credentials}"},
            timeout=5
        )
        if response.status_code == 200:
            auth_data = response.json()
            if auth_data.get("valid") and "user" in auth_data:
                return auth_data["user"]
            else:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid token"
                )
        else:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
    except requests.RequestException:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Auth service unavailable"
        )

async def require_admin_or_operator_role(current_user: dict = Depends(verify_token_with_auth_service)):
    """Require admin or operator role"""
    if current_user.get("role") not in ["admin", "operator"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin or operator role required"
        )
    return current_user

# Helper functions
def get_target_services(conn, target_id: int) -> List[TargetService]:
    """Get all services for a target"""
    cursor = conn.cursor()
    cursor.execute("""
        SELECT 
            ts.id, ts.service_type, sd.display_name, sd.category,
            ts.port, sd.default_port, ts.is_secure, ts.is_enabled,
            ts.is_custom_port, ts.discovery_method, ts.connection_status,
            ts.last_checked, ts.notes, ts.created_at
        FROM target_services ts
        JOIN service_definitions sd ON ts.service_type = sd.service_type
        WHERE ts.target_id = %s
        ORDER BY sd.category, sd.display_name
    """, (target_id,))
    
    services = []
    for row in cursor.fetchall():
        services.append(TargetService(
            id=row['id'],
            service_type=row['service_type'],
            display_name=row['display_name'],
            category=row['category'],
            port=row['port'],
            default_port=row['default_port'],
            is_secure=row['is_secure'],
            is_enabled=row['is_enabled'],
            is_custom_port=row['is_custom_port'],
            discovery_method=row['discovery_method'],
            connection_status=row['connection_status'],
            last_checked=row['last_checked'],
            notes=row['notes'],
            created_at=row['created_at']
        ))
    return services

def get_target_credentials(conn, target_id: int) -> List[TargetCredential]:
    """Get all credentials for a target"""
    cursor = conn.cursor()
    cursor.execute("""
        SELECT 
            tc.id, tc.credential_id, c.name as credential_name,
            c.credential_type, tc.service_types, tc.is_primary, tc.created_at
        FROM target_credentials tc
        JOIN credentials c ON tc.credential_id = c.id
        WHERE tc.target_id = %s
        ORDER BY tc.is_primary DESC, c.name
    """, (target_id,))
    
    credentials = []
    for row in cursor.fetchall():
        credentials.append(TargetCredential(
            id=row['id'],
            credential_id=row['credential_id'],
            credential_name=row['credential_name'],
            credential_type=row['credential_type'],
            service_types=row['service_types'] or [],
            is_primary=row['is_primary'],
            created_at=row['created_at']
        ))
    return credentials

# SERVICE DEFINITIONS ENDPOINTS

@app.get("/service-definitions", response_model=ServiceDefinitionResponse)
async def list_service_definitions(
    category: Optional[str] = Query(None, description="Filter by category"),
    common_only: bool = Query(False, description="Show only common services"),
    current_user: dict = Depends(verify_token_with_auth_service)
):
    """List all available service definitions"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        query = "SELECT * FROM service_definitions WHERE 1=1"
        params = []
        
        if category:
            query += " AND category = %s"
            params.append(category)
            
        if common_only:
            query += " AND is_common = true"
            
        query += " ORDER BY category, display_name"
        
        cursor.execute(query, params)
        
        services = []
        for row in cursor.fetchall():
            services.append(ServiceDefinition(
                id=row['id'],
                service_type=row['service_type'],
                display_name=row['display_name'],
                category=row['category'],
                default_port=row['default_port'],
                is_secure_by_default=row['is_secure_by_default'],
                description=row['description'],
                is_common=row['is_common'],
                created_at=row['created_at']
            ))
        
        return ServiceDefinitionResponse(services=services, total=len(services))
        
    except Exception as e:
        logger.error(f"Error listing service definitions: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

# ENHANCED TARGET ENDPOINTS

@app.get("/targets", response_model=TargetListResponse)
async def list_targets(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    os_type: Optional[str] = Query(None, description="Filter by OS type"),
    service_type: Optional[str] = Query(None, description="Filter by service type"),
    tag: Optional[str] = Query(None, description="Filter by tag"),
    current_user: dict = Depends(verify_token_with_auth_service)
):
    """List all targets with their services and credentials"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Build query with filters
        query = """
            SELECT DISTINCT t.id, t.name, t.hostname, t.ip_address, t.os_type, 
                   t.os_version, t.description, t.tags, t.created_at, t.updated_at
            FROM targets t
        """
        params = []
        where_conditions = []
        
        if os_type:
            where_conditions.append("t.os_type = %s")
            params.append(os_type)
            
        if service_type:
            query += " JOIN target_services ts ON t.id = ts.target_id"
            where_conditions.append("ts.service_type = %s AND ts.is_enabled = true")
            params.append(service_type)
            
        if tag:
            where_conditions.append("%s = ANY(t.tags)")
            params.append(tag)
            
        if where_conditions:
            query += " WHERE " + " AND ".join(where_conditions)
            
        query += " ORDER BY t.created_at DESC OFFSET %s LIMIT %s"
        params.extend([skip, limit])
        
        cursor.execute(query, params)
        
        targets = []
        for row in cursor.fetchall():
            # Get services and credentials for each target
            services = get_target_services(conn, row['id'])
            credentials = get_target_credentials(conn, row['id'])
            
            targets.append(Target(
                id=row['id'],
                name=row['name'],
                hostname=row['hostname'],
                ip_address=row['ip_address'],
                os_type=row['os_type'],
                os_version=row['os_version'],
                description=row['description'],
                tags=row['tags'] or [],
                services=services,
                credentials=credentials,
                created_at=row['created_at'],
                updated_at=row['updated_at']
            ))
        
        # Get total count
        count_query = "SELECT COUNT(DISTINCT t.id) FROM targets t"
        if service_type:
            count_query += " JOIN target_services ts ON t.id = ts.target_id"
        if where_conditions:
            count_query += " WHERE " + " AND ".join(where_conditions[:-2] if service_type else where_conditions[:-1])
        
        cursor.execute(count_query, params[:-2])
        total = cursor.fetchone()['count']
        
        return TargetListResponse(targets=targets, total=total)
        
    except Exception as e:
        logger.error(f"Error listing targets: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.post("/targets", response_model=Target)
async def create_target(
    target: TargetCreate,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Create a new target with services and credentials"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Create target
        cursor.execute("""
            INSERT INTO targets (name, hostname, ip_address, os_type, os_version, description, tags, created_at)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            target.name, target.hostname, target.ip_address, target.os_type,
            target.os_version, target.description, target.tags, datetime.utcnow()
        ))
        
        target_id = cursor.fetchone()['id']
        
        # Create services
        for service in target.services:
            # Check if port is custom
            cursor.execute("""
                SELECT default_port FROM service_definitions WHERE service_type = %s
            """, (service.service_type,))
            
            default_port_row = cursor.fetchone()
            if not default_port_row:
                raise HTTPException(status_code=400, detail=f"Unknown service type: {service.service_type}")
                
            is_custom_port = service.port != default_port_row['default_port']
            
            cursor.execute("""
                INSERT INTO target_services 
                (target_id, service_type, port, is_secure, is_enabled, is_custom_port, discovery_method, created_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                target_id, service.service_type, service.port, service.is_secure,
                service.is_enabled, is_custom_port, 'manual', datetime.utcnow()
            ))
        
        # Create credential assignments
        for cred in target.credentials:
            cursor.execute("""
                INSERT INTO target_credentials 
                (target_id, credential_id, service_types, is_primary, created_at)
                VALUES (%s, %s, %s, %s, %s)
            """, (
                target_id, cred.credential_id, cred.service_types,
                cred.is_primary, datetime.utcnow()
            ))
        
        conn.commit()
        
        # Return the created target with services and credentials
        cursor.execute("""
            SELECT id, name, hostname, ip_address, os_type, os_version, 
                   description, tags, created_at, updated_at
            FROM targets WHERE id = %s
        """, (target_id,))
        
        target_row = cursor.fetchone()
        services = get_target_services(conn, target_id)
        credentials = get_target_credentials(conn, target_id)
        
        return Target(
            id=target_row['id'],
            name=target_row['name'],
            hostname=target_row['hostname'],
            ip_address=target_row['ip_address'],
            os_type=target_row['os_type'],
            os_version=target_row['os_version'],
            description=target_row['description'],
            tags=target_row['tags'] or [],
            services=services,
            credentials=credentials,
            created_at=target_row['created_at'],
            updated_at=target_row['updated_at']
        )
        
    except psycopg2.IntegrityError as e:
        conn.rollback()
        if "unique constraint" in str(e).lower():
            raise HTTPException(status_code=400, detail="Target name already exists")
        raise HTTPException(status_code=400, detail="Database constraint violation")
    except Exception as e:
        conn.rollback()
        logger.error(f"Error creating target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.get("/targets/{target_id}", response_model=Target)
async def get_target(
    target_id: int,
    current_user: dict = Depends(verify_token_with_auth_service)
):
    """Get a specific target with its services and credentials"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, name, hostname, ip_address, os_type, os_version,
                   description, tags, created_at, updated_at
            FROM targets WHERE id = %s
        """, (target_id,))
        
        target_row = cursor.fetchone()
        if not target_row:
            raise HTTPException(status_code=404, detail="Target not found")
        
        services = get_target_services(conn, target_id)
        credentials = get_target_credentials(conn, target_id)
        
        return Target(
            id=target_row['id'],
            name=target_row['name'],
            hostname=target_row['hostname'],
            ip_address=target_row['ip_address'],
            os_type=target_row['os_type'],
            os_version=target_row['os_version'],
            description=target_row['description'],
            tags=target_row['tags'] or [],
            services=services,
            credentials=credentials,
            created_at=target_row['created_at'],
            updated_at=target_row['updated_at']
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.put("/targets/{target_id}", response_model=Target)
async def update_target(
    target_id: int,
    target: TargetUpdate,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Update an existing target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Check if target exists
        cursor.execute("SELECT id FROM targets WHERE id = %s", (target_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Target not found")
        
        # Build dynamic update query for only provided fields
        update_fields = []
        update_values = []
        
        if target.name is not None:
            update_fields.append("name = %s")
            update_values.append(target.name)
        if target.hostname is not None:
            update_fields.append("hostname = %s")
            update_values.append(target.hostname)
        if target.ip_address is not None:
            update_fields.append("ip_address = %s")
            update_values.append(target.ip_address)
        if target.os_type is not None:
            update_fields.append("os_type = %s")
            update_values.append(target.os_type)
        if target.os_version is not None:
            update_fields.append("os_version = %s")
            update_values.append(target.os_version)
        if target.description is not None:
            update_fields.append("description = %s")
            update_values.append(target.description)
        if target.tags is not None:
            update_fields.append("tags = %s")
            update_values.append(target.tags)
        
        if not update_fields:
            raise HTTPException(status_code=400, detail="No fields provided for update")
        
        # Always update the updated_at timestamp
        update_fields.append("updated_at = %s")
        update_values.append(datetime.utcnow())
        update_values.append(target_id)
        
        query = f"UPDATE targets SET {', '.join(update_fields)} WHERE id = %s"
        cursor.execute(query, update_values)
        
        conn.commit()
        
        # Return updated target
        return await get_target(target_id, current_user)
        
    except psycopg2.IntegrityError as e:
        conn.rollback()
        if "unique constraint" in str(e).lower():
            if "hostname" in str(e).lower():
                raise HTTPException(status_code=400, detail="Hostname already exists")
            elif "ip_address" in str(e).lower():
                raise HTTPException(status_code=400, detail="IP address already exists")
        raise HTTPException(status_code=400, detail="Database constraint violation")
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error updating target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.delete("/targets/{target_id}")
async def delete_target(
    target_id: int,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Delete a target and all its associated services and credentials"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Check if target exists
        cursor.execute("SELECT id FROM targets WHERE id = %s", (target_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Target not found")
        
        # Delete associated services (cascade should handle this, but let's be explicit)
        cursor.execute("DELETE FROM target_services WHERE target_id = %s", (target_id,))
        
        # Delete associated credentials
        cursor.execute("DELETE FROM target_credentials WHERE target_id = %s", (target_id,))
        
        # Delete the target
        cursor.execute("DELETE FROM targets WHERE id = %s", (target_id,))
        
        conn.commit()
        
        return {"message": "Target deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error deleting target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

# SERVICE MANAGEMENT ENDPOINTS

@app.post("/targets/{target_id}/services", response_model=TargetService)
async def add_service_to_target(
    target_id: int,
    service: TargetServiceCreate,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Add a service to a target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Verify target exists
        cursor.execute("SELECT id FROM targets WHERE id = %s", (target_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Target not found")
        
        # Get service definition
        cursor.execute("""
            SELECT default_port, display_name, category 
            FROM service_definitions WHERE service_type = %s
        """, (service.service_type,))
        
        service_def = cursor.fetchone()
        if not service_def:
            raise HTTPException(status_code=400, detail=f"Unknown service type: {service.service_type}")
        
        is_custom_port = service.port != service_def['default_port']
        
        # Create service
        cursor.execute("""
            INSERT INTO target_services 
            (target_id, service_type, port, is_secure, is_enabled, is_custom_port, 
             discovery_method, notes, created_at)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            target_id, service.service_type, service.port, service.is_secure,
            service.is_enabled, is_custom_port, 'manual', service.notes, datetime.utcnow()
        ))
        
        service_id = cursor.fetchone()['id']
        conn.commit()
        
        return TargetService(
            id=service_id,
            service_type=service.service_type,
            display_name=service_def['display_name'],
            category=service_def['category'],
            port=service.port,
            default_port=service_def['default_port'],
            is_secure=service.is_secure,
            is_enabled=service.is_enabled,
            is_custom_port=is_custom_port,
            discovery_method='manual',
            connection_status='unknown',
            last_checked=None,
            notes=service.notes,
            created_at=datetime.utcnow()
        )
        
    except psycopg2.IntegrityError as e:
        conn.rollback()
        if "unique constraint" in str(e).lower():
            raise HTTPException(status_code=400, detail="Service already exists on this target")
        raise HTTPException(status_code=400, detail="Database constraint violation")
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error adding service to target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.put("/targets/{target_id}/services/{service_id}", response_model=TargetService)
async def update_service(
    target_id: int,
    service_id: int,
    service: TargetServiceUpdate,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Update a service on a target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Verify target and service exist
        cursor.execute("""
            SELECT ts.id, ts.service_type, sd.default_port, sd.display_name, sd.category
            FROM target_services ts
            JOIN service_definitions sd ON ts.service_type = sd.service_type
            WHERE ts.id = %s AND ts.target_id = %s
        """, (service_id, target_id))
        
        existing_service = cursor.fetchone()
        if not existing_service:
            raise HTTPException(status_code=404, detail="Service not found")
        
        # Build dynamic update query for only provided fields
        update_fields = []
        update_values = []
        
        if service.port is not None:
            is_custom_port = service.port != existing_service['default_port']
            update_fields.append("port = %s")
            update_fields.append("is_custom_port = %s")
            update_values.extend([service.port, is_custom_port])
        if service.is_secure is not None:
            update_fields.append("is_secure = %s")
            update_values.append(service.is_secure)
        if service.is_enabled is not None:
            update_fields.append("is_enabled = %s")
            update_values.append(service.is_enabled)
        if service.notes is not None:
            update_fields.append("notes = %s")
            update_values.append(service.notes)
        
        if not update_fields:
            raise HTTPException(status_code=400, detail="No fields provided for update")
        
        update_values.extend([service_id, target_id])
        query = f"UPDATE target_services SET {', '.join(update_fields)} WHERE id = %s AND target_id = %s"
        cursor.execute(query, update_values)
        
        conn.commit()
        
        # Get updated service data
        cursor.execute("""
            SELECT ts.*, sd.display_name, sd.category, sd.default_port
            FROM target_services ts
            JOIN service_definitions sd ON ts.service_type = sd.service_type
            WHERE ts.id = %s AND ts.target_id = %s
        """, (service_id, target_id))
        
        updated_service = cursor.fetchone()
        
        return TargetService(
            id=service_id,
            service_type=updated_service['service_type'],
            display_name=updated_service['display_name'],
            category=updated_service['category'],
            port=updated_service['port'],
            default_port=updated_service['default_port'],
            is_secure=updated_service['is_secure'],
            is_enabled=updated_service['is_enabled'],
            is_custom_port=updated_service['is_custom_port'],
            discovery_method=updated_service['discovery_method'],
            connection_status=updated_service['connection_status'] or 'unknown',
            last_checked=updated_service['last_checked'],
            notes=updated_service['notes'],
            created_at=updated_service['created_at']
        )
        
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error updating service: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.delete("/targets/{target_id}/services/{service_id}")
async def delete_service(
    target_id: int,
    service_id: int,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Delete a service from a target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Verify service exists
        cursor.execute("""
            SELECT id FROM target_services 
            WHERE id = %s AND target_id = %s
        """, (service_id, target_id))
        
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Service not found")
        
        # Delete service
        cursor.execute("""
            DELETE FROM target_services 
            WHERE id = %s AND target_id = %s
        """, (service_id, target_id))
        
        conn.commit()
        
        return {"message": "Service deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error deleting service: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.post("/targets/{target_id}/services/{service_id}/test")
async def test_service_connection(
    target_id: int,
    service_id: int,
    current_user: dict = Depends(verify_token_with_auth_service)
):
    """Test connection to a service"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Get service and target details
        cursor.execute("""
            SELECT ts.service_type, ts.port, ts.is_secure, t.hostname, t.ip_address
            FROM target_services ts
            JOIN targets t ON ts.target_id = t.id
            WHERE ts.id = %s AND ts.target_id = %s
        """, (service_id, target_id))
        
        service_data = cursor.fetchone()
        if not service_data:
            raise HTTPException(status_code=404, detail="Service not found")
        
        # Simple connection test (this could be enhanced with actual service-specific tests)
        import socket
        
        host = service_data['hostname'] or service_data['ip_address']
        port = service_data['port']
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)  # 5 second timeout
            result = sock.connect_ex((host, port))
            sock.close()
            
            if result == 0:
                status = "success"
                message = f"Connection to {host}:{port} successful"
            else:
                status = "failed"
                message = f"Connection to {host}:{port} failed"
                
        except Exception as e:
            status = "error"
            message = f"Connection test error: {str(e)}"
        
        # Update last_checked timestamp
        cursor.execute("""
            UPDATE target_services 
            SET connection_status = %s, last_checked = %s
            WHERE id = %s
        """, (status, datetime.utcnow(), service_id))
        
        conn.commit()
        
        return {
            "status": status,
            "message": message,
            "service_type": service_data['service_type'],
            "host": host,
            "port": port,
            "tested_at": datetime.utcnow().isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error testing service connection: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

# CREDENTIAL MANAGEMENT ENDPOINTS

@app.post("/targets/{target_id}/credentials", response_model=TargetCredential)
async def add_credential_to_target(
    target_id: int,
    credential: TargetCredentialCreate,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Add a credential to a target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Verify target exists
        cursor.execute("SELECT id FROM targets WHERE id = %s", (target_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Target not found")
        
        # Verify credential exists
        cursor.execute("SELECT id, name FROM credentials WHERE id = %s", (credential.credential_id,))
        cred_data = cursor.fetchone()
        if not cred_data:
            raise HTTPException(status_code=404, detail="Credential not found")
        
        # Create target credential association
        cursor.execute("""
            INSERT INTO target_credentials 
            (target_id, credential_id, service_types, is_primary, created_at)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id
        """, (
            target_id, credential.credential_id, credential.service_types,
            credential.is_primary, datetime.utcnow()
        ))
        
        tc_id = cursor.fetchone()['id']
        conn.commit()
        
        return TargetCredential(
            id=tc_id,
            credential_id=credential.credential_id,
            credential_name=cred_data['name'],
            service_types=credential.service_types,
            is_primary=credential.is_primary,
            created_at=datetime.utcnow()
        )
        
    except psycopg2.IntegrityError as e:
        conn.rollback()
        if "unique constraint" in str(e).lower():
            raise HTTPException(status_code=400, detail="Credential already associated with this target")
        raise HTTPException(status_code=400, detail="Database constraint violation")
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error adding credential to target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.put("/targets/{target_id}/credentials/{credential_id}", response_model=TargetCredential)
async def update_target_credential(
    target_id: int,
    credential_id: int,
    credential: TargetCredentialCreate,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Update a credential association on a target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Verify target credential exists
        cursor.execute("""
            SELECT tc.id, c.name
            FROM target_credentials tc
            JOIN credentials c ON tc.credential_id = c.id
            WHERE tc.target_id = %s AND tc.credential_id = %s
        """, (target_id, credential_id))
        
        tc_data = cursor.fetchone()
        if not tc_data:
            raise HTTPException(status_code=404, detail="Target credential association not found")
        
        # Update target credential
        cursor.execute("""
            UPDATE target_credentials 
            SET service_types = %s, is_primary = %s
            WHERE target_id = %s AND credential_id = %s
        """, (
            credential.service_types, credential.is_primary, target_id, credential_id
        ))
        
        conn.commit()
        
        return TargetCredential(
            id=tc_data['id'],
            credential_id=credential_id,
            credential_name=tc_data['name'],
            service_types=credential.service_types,
            is_primary=credential.is_primary,
            created_at=datetime.utcnow()
        )
        
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error updating target credential: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.delete("/targets/{target_id}/credentials/{credential_id}")
async def delete_target_credential(
    target_id: int,
    credential_id: int,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Remove a credential association from a target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Verify target credential exists
        cursor.execute("""
            SELECT id FROM target_credentials 
            WHERE target_id = %s AND credential_id = %s
        """, (target_id, credential_id))
        
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Target credential association not found")
        
        # Delete target credential
        cursor.execute("""
            DELETE FROM target_credentials 
            WHERE target_id = %s AND credential_id = %s
        """, (target_id, credential_id))
        
        conn.commit()
        
        return {"message": "Credential association deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error deleting target credential: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

# MIGRATION ENDPOINT

@app.post("/migrate-schema", response_model=MigrationStatus)
async def migrate_schema(
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Migrate existing single-service targets to multi-service schema"""
    if current_user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin role required for migration")
    
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT migrate_old_targets_to_new_schema()")
        result = cursor.fetchone()
        conn.commit()
        
        return MigrationStatus(
            success=True,
            services_created=0,  # Parse from result if needed
            credentials_created=0,  # Parse from result if needed
            message=result[0] if result else "Migration completed"
        )
        
    except Exception as e:
        conn.rollback()
        logger.error(f"Error during migration: {e}")
        raise HTTPException(status_code=500, detail=f"Migration failed: {str(e)}")
    finally:
        conn.close()

# TARGET CRUD ENDPOINTS (MISSING OPERATIONS)
@app.put("/targets/{target_id}", response_model=Target)
async def update_target_endpoint(
    target_id: int,
    target: TargetUpdate,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Update an existing target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Check if target exists
        cursor.execute("SELECT id FROM targets WHERE id = %s", (target_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Target not found")
        
        # Build dynamic update query for only provided fields
        update_fields = []
        update_values = []
        
        if target.name is not None:
            update_fields.append("name = %s")
            update_values.append(target.name)
        if target.hostname is not None:
            update_fields.append("hostname = %s")
            update_values.append(target.hostname)
        if target.ip_address is not None:
            update_fields.append("ip_address = %s")
            update_values.append(target.ip_address)
        if target.os_type is not None:
            update_fields.append("os_type = %s")
            update_values.append(target.os_type)
        if target.os_version is not None:
            update_fields.append("os_version = %s")
            update_values.append(target.os_version)
        if target.description is not None:
            update_fields.append("description = %s")
            update_values.append(target.description)
        if target.tags is not None:
            update_fields.append("tags = %s")
            update_values.append(target.tags)
        
        if not update_fields:
            raise HTTPException(status_code=400, detail="No fields provided for update")
        
        # Always update the updated_at timestamp
        update_fields.append("updated_at = %s")
        update_values.append(datetime.utcnow())
        update_values.append(target_id)
        
        query = f"UPDATE targets SET {', '.join(update_fields)} WHERE id = %s"
        cursor.execute(query, update_values)
        conn.commit()
        
        # Get updated target data
        cursor.execute("""
            SELECT id, name, hostname, ip_address, os_type, os_version,
                   description, tags, created_at, updated_at
            FROM targets WHERE id = %s
        """, (target_id,))
        
        target_row = cursor.fetchone()
        services = get_target_services(conn, target_id)
        credentials = get_target_credentials(conn, target_id)
        
        return Target(
            id=target_row['id'],
            name=target_row['name'],
            hostname=target_row['hostname'],
            ip_address=target_row['ip_address'],
            os_type=target_row['os_type'],
            os_version=target_row['os_version'],
            description=target_row['description'],
            tags=target_row['tags'] or [],
            services=services,
            credentials=credentials,
            created_at=target_row['created_at'],
            updated_at=target_row['updated_at']
        )
        
    except psycopg2.IntegrityError as e:
        conn.rollback()
        if "unique constraint" in str(e).lower():
            if "hostname" in str(e).lower():
                raise HTTPException(status_code=400, detail="Hostname already exists")
            elif "ip_address" in str(e).lower():
                raise HTTPException(status_code=400, detail="IP address already exists")
        raise HTTPException(status_code=400, detail="Database constraint violation")
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error updating target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.delete("/targets/{target_id}")
async def delete_target_endpoint(
    target_id: int,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Delete a target and all its associated services and credentials"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Check if target exists
        cursor.execute("SELECT id FROM targets WHERE id = %s", (target_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Target not found")
        
        # Delete associated services (cascade should handle this, but let's be explicit)
        cursor.execute("DELETE FROM target_services WHERE target_id = %s", (target_id,))
        
        # Delete associated credentials
        cursor.execute("DELETE FROM target_credentials WHERE target_id = %s", (target_id,))
        
        # Delete the target
        cursor.execute("DELETE FROM targets WHERE id = %s", (target_id,))
        
        conn.commit()
        
        return {"message": "Target deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error deleting target: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

@app.delete("/targets/{target_id}/services/{service_id}")
async def delete_service_endpoint(
    target_id: int,
    service_id: int,
    current_user: dict = Depends(require_admin_or_operator_role)
):
    """Delete a service from a target"""
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # Verify service exists
        cursor.execute("""
            SELECT id FROM target_services 
            WHERE id = %s AND target_id = %s
        """, (service_id, target_id))
        
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail="Service not found")
        
        # Delete service
        cursor.execute("""
            DELETE FROM target_services 
            WHERE id = %s AND target_id = %s
        """, (service_id, target_id))
        
        conn.commit()
        
        return {"message": "Service deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        logger.error(f"Error deleting service: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        conn.close()

# HEALTH CHECK
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1")
        conn.close()
        return {"status": "healthy", "version": "2.0.0", "features": ["multi-service", "legacy-compatibility"]}
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=503, detail="Service unhealthy")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=3005)